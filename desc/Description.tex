% !TeX document-id = {47019ce0-69e4-419e-8601-5a0ff13ff74b}
\documentclass[authhead, center]{hayektex}
\usepackage{mybindings}

\title{cool camels: project description}
\note{Lectures by Prof. Henri Darmon}
\email{nicholas.hayek@mail.mcgill.ca}
\author{Hayek, Huo, Beloiu}

\usepackage{xhfill}
\usepackage{iexec}
\usepackage{dashbox}
%!TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
%\iexec[quiet]{/Users/nicholashayek/hayekn.github.io/scripts/refresh.sh MATH 456 "Algebra 3 Notes.pdf"}
%\iexec[quiet]{rm /Users/nicholashayek/.config/texstudio/completion/autogenerated/hayektex.cwl}
\renewcommand{\underline}{\uline}
\setlength{\fboxsep}{7pt}
\usepackage{sourcecodepro}
%{
	\usepackage{listings}
	\definecolor{codegreen}{rgb}{0,0.6,0}
	\definecolor{codegray}{rgb}{0.5,0.5,0.5}
	\definecolor{codepurple}{rgb}{0.58,0,0.82}
	\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
	\lstdefinestyle{mystyle}{
		backgroundcolor=\color{backcolour},   
		commentstyle=\color{blue!50},
		keywordstyle=\color{magenta},
		numberstyle=\tiny\color{codegreen},
		stringstyle=\color{codepurple},
		basicstyle=\ttfamily\scriptsize,
		breakatwhitespace=false,         
		breaklines=true,                 
		captionpos=b,                    
		keepspaces=true,                 
		numbers=none,                    
		numbersep=5pt,                  
		showspaces=false,               
		showstringspaces=false,
		showtabs=false,                  
		tabsize=2,
		xleftmargin=0cm,
		language = [Objective]Caml
	}
	\lstset{style=mystyle, firstnumber=last}
\newcommand{\aand}{\runin{\;and\;}}
\newcommand{\oor}{\runin{\;or\;}}
\begin{document}
\section{Problem}\small
\textit{Boolean expressions} define how a series of \textit{operations} (\runin{not, or, and}) act on set of boolean \textit{variables}. For example, consider the following:
$$e = \runin{not} (a \runin{\;and\;\;} (b \runin{\;or\;\;} a)) = \lnot(a \land (b \lor a))$$
where we adopt the conventions \runin{not}=$\lnot$, \runin{or}=$\lor$, and \runin{and}=$\land$. In OCaml, we can define these expressions recursively with types:
\begin{lstlisting}
	type exp =
		|Var of int
		|Not of expression
		|And of expression * expression
		|Or of expression * expression;;
\end{lstlisting}
Hence, the expression above may be written as
\begin{lstlisting}
	let e = Not(And(1, Or(2, 1)))
\end{lstlisting}
We wish to understand when two boolean expressions {imply eachother}, i.e. when the statement "if $e_1$ then $e_2$" holds. Mathematicians have a particular interest in machines which can verify logical implications, called \textit{SAT solvers}, and we will implement a simple one below by solving the following sub-problems:
\begin{enumerate}
	\item Convert a recursively-defined boolean expression into human readable text.
	\item Extract an expression's variable names in a well-ordered fashion.
	\item Evaluate an expression on fixed inputs values.
	\item Compute the values of a boolean expression over all possible input combinations (i.e. make a "truth table"). Provide a readable summary of an expression using (1), (2), and the truth table.
	\item Determine if a boolean expression is identically true, if a solution for it exists, and, if so, on what inputs.
	\item \textbf{Determine if two boolean expressions have an implication relation, i.e. $\boldsymbol{e_1 \implies e_2}$,  $\boldsymbol{e_1 \impliedby e_2}$, or $\boldsymbol{e_1 \iff e_2}$.}
\end{enumerate}
\section{Solution}
The third and fourth questions have been solved on OCaml (\textit{ocaml.org $\to$ exercises $\to$ intermediate}), in both the $n=2$ and general cases. However, their solution is not tail-recursive or space efficient. We provide the following solution outlines for the problems above, which, if recursive, should be made tail recursive using continuations.
\begin{enumerate}
	\item Implement \code{printExpression}, as described above.  One should approach this by pattern matching on the expression \code{e}: if \code{e} is a variable, return it; otherwise, place the appropriate operator character (i.e. $\lnot, \lor, \land$) between (or in front) of a recursive call on the expression(s) contained in it. 
	\item Implement \code{inputList} and \code{trInputList}, which take an expression \code{e} and returns a sorted list of integers. We pattern match: if \code{e} is a variable, check if we've seen it already (via an accumulator, say), and add it if not. Otherwise, recursively call on its arguments. At the end, use \code{List.sort} to get input names in increasing order.
	\item Implement \code{evaluateExpression} in 3 ways: recursively, tail-recursively, and with memoization. Pattern match on the expression: if a variable, return the variable's assignment. Otherwise, perform the appropriate logical operation (i.e. \code{not}, \code{||}, \code{\&\&}) on the recursive call of its sub-expressions. Use a hash-table to accomplish memoization.
	\item Implement \code{generateCombinations}, which generates a 2D list of $2^n$ rows consisting of all length-$n$ true-false combinations. Then implement \code{truthTable}, which returns a list of input-output combinations. Use higher order functions to allow the user to choose which evaluator to use. \code{Printf.printf} provides the functionality to display the results from (1), (2), and (4).
	\item Implement \code{alwaysTrue, existsSolution}, and \code{findSolutions}. After generating the truth table in (3), we analyze the solutions (are they all true/false?; if a combination evaluates to true, what was it)? 
	\item Implement \code{satSolverImplies, satSolverImpliedBy, satSolverIff}. For $e_1 \implies e_2$ to hold, we require exactly that $e_2$ be true when $e_1$ is true. This is encoded in the verification of $e := (\lnot e_1) \lor e_2$. Generate the truth table for $e$, and use \code{alwaysTrue} to see if it always holds. $e_1 \impliedby e_2$ and $e_1 \iff e_2$ follow similarly. 
	\\We look for the following types, where \code{<evaluator> = exp -> (int*bool) list -> bool}.
	\begin{center}
		\begin{tabular}{l||l}
		Name & Type\\\hline
		\code{printExpression (r/tr)} & \code{exp -> string}\\
		\code{inputList (r/tr)} & \code{exp -> int list}\\
		\code{evaluateExpression (r/tr/memo)}&\code{exp -> (int * bool) list -> bool}\\
		\code{generateCombinations} & \code{int -> bool list list}\\
		\code{truthTable} & \code{<evaluator> -> exp -> (bool list * bool) list}\\
		\code{alwaysTrue, existsSolution} & \code{<evaluator> -> exp -> bool}\\
		\code{findSolutions} & \code{<evaluator> -> exp -> (bool list * bool) list}\\
		\code{satSolverImplies/ImpliedBy/Iff} & \code{<evaluator> -> exp -> exp -> bool}
	\end{tabular}
	\end{center}
	Good luck \faSmileO
%	\item Only (1) and (2) require recursion, and tail-recursive versions may be accomplished easily via continuations. Generalizing to $n$, we wish to have a non-arbitrary ordering of variables. Strings are not good for this, so use integers. For example:
%\begin{lstlisting}
%let e = Or(And(Not(Var(3)), Var(1)), Var(2))
%\end{lstlisting}
%	then we need to extract these inputs recursively into a sorted list (i.e. \code{[1;2;3]}) and create pairings between a row of bools (recall: there are $2^n$ of these) and this list of variables. Finally, evaluate. Memoization may be accomplished by checking and storing sub-expressions in a hash table.
\end{enumerate}


\end{document}